#summary The PGF binary searialization is still under development

=Basic Types=

 * Int8
 * Int16
 * Int
 * String
 * Float
 * List

=PGF=

|| *type*       || *description*                 ||
|| `Int16`      || major PGF version             ||
|| `Int16`      || minor PGF version             ||
|| `[Flag]`     || flags for the whole grammar   ||
|| `Abstract`   || abstract syntax               ||
|| `[Concrete]` || list of all concrete syntaxes ||

=Flag=

|| *type*     || *description*                 ||
|| `String`   || flag name                     ||
|| `Literal`  || flag value                    ||

=Abstract=

|| *type*     || *description*                 ||
|| `String`   || abstract syntax name          ||
|| `[Flag]`   || flags for the abstract syntax ||
|| `[AbsFun]` || list of abstract functions    ||
|| `[AbsCat]` || list of abstract categories   ||

=!AbsFun=

|| *type*       || *description*                            ||
|| `String`     || function name                            ||
|| `Type`       || function's type signature                ||
|| `Int`        || function's arrity                        ||
|| `[Equation]` || definitional equations for this function ||

=!AbsCat=

|| *type*       || *description*                        ||
|| `String`     || category name                        ||
|| `[Hypo]`     || list of hypotheses for this category ||
|| `[String]`   || list of functions for this category in source-code order ||

=Type=

|| *type*         || *description*                      ||
|| `[Hypo]`       || list of hypotheses for this type   ||
|| `String`       || the name of the return category    ||
|| `[Expression]` || arguments for the return category  ||

=Hypo=

|| *type*     || *description*                                  ||
|| `BindType` || binding type                                   ||
|| `String`   || variable name or `'_'` if no variable is bound ||
|| `Type`     || the type of the variable                       ||

=Equation=

|| *type*       || *description*        ||
|| `[Pattern]`  || sequence of patterns ||
|| `Expression` || expression           ||

=Pattern=

|| *type*      || *description*  ||
|| `Int8`      || pattern tag    ||

1. tag=0 - application (`c p1 p2 ... pn`)
|| *type*      || *description*                          ||
|| `String`    || abstract function name                 ||
|| `[Pattern]` || list of sub patterns for the arguments ||

2. tag=1 - variable
|| *type*      || *description* ||
|| `String`    || variable name ||

3. tag=2 - variable@pattern
|| *type*      || *description* ||
|| `String`    || variable name ||
|| `Pattern`   || sub-pattern ||

4. tag=3 - wildcard (`_`). No more fields

5. tag=4 - literal (`"aa"`, `1`, `3.14`)
|| *type*      || *description* ||
|| `Literal`   || literal value ||

6. tag=5 - pattern matching over implicit argument ({p})
|| *type*      || *description* ||
|| `Pattern`   || variable name ||

7. tag=6 - inaccessible pattern
|| *type*      || *description* ||
|| `Expr`      || the content of the inaccessible pattern ||

=Expression=

|| *type*     || *description*  ||
|| `Int8`     || expression tag ||

1. tag=0 - lambda abstraction (`\x -> ...`)
|| *type*       || *description*                      ||
|| `BindType`   || expression tag                     ||
|| `String`     || variable name                      ||
|| `Expression` || the body of the lambda abstraction ||

2. tag=1 - application (`f x`)
|| *type*       || *description*                           ||
|| `Expression` || the left expression in the application  ||
|| `Expression` || the right expression in the application ||

3. tag=2 - literal (`"aa"`, `1`, `3.14`)
|| *type*    || *description*             ||
|| `Literal` || the value of the literal  ||

4. tag=3 - meta variable (`?0`,`?1`)
|| *type* || *description*               ||
|| `Int`  || the id of the meta variable ||

5. tag=4 - abstract function name (`PredVP`, `IndefArt`)
|| *type*   || *description*          ||
|| `String` || abstract function name ||

6. tag=5 - variable
|| *type* || *description*                       ||
|| `Int`  || the de Bruijn index of the variable ||

7. tag=6 - expression with type annotation (`<e : t>`)
|| *type*       || *description*              ||
|| `Expression` || the annotated expression   ||
|| `Type`       || the type of the expression ||

8. tag=7 - implicit argument (`{e}`)
|| *type*       || *description*                   ||
|| `Expression` || the expression for the argument ||

=!BindType=

|| *type* || *description* ||
|| `Int8` || tag           ||

The tag has two possible values:
 * tag=0, explicit argument
 * tag=1, implicit argument

=Concrete=

|| *type*         || *description*                                           ||
|| `String`       || concrete syntax name                                    ||
|| `[Flag]`       || flags for the concrete syntax                           ||
|| `[PrintName]`  || list of all print names defined in this concrete syntax ||
|| `[Sequence]`   || list of sequences                                       ||
|| `[CncFun]`     || list of concrete functions                              ||
|| `[Production]` || list of productions                                     ||
|| `[CncCat]`     || list of concrete categories                             ||
|| `Int`          || total number of forest ids allocated for the grammar    ||

=!PrintName=

|| *type*   || *description*                                                          ||
|| `String` || name of abstract function or category for which the print name applies ||
|| `String` || the print name itself                                                  ||

=Sequence=

|| *type*     || *description*                                ||
|| `[Symbol]` || list of symbols that constitute the sequence ||

=Symbol=

|| *type* || *description*                              ||
|| `Int8` || tag which says what kind of symbol this is ||

1. tag=0 or tag=1
|| *type* || *description*     ||
|| `Int`  || argument index    ||
|| `Int`  || constituent index ||

2. tag=2
|| *type*       || *description*      ||
|| `[String]`   || sequence of tokens ||

3. tag=3
|| *type*          || *description*            ||
|| `[String]`      || sequence of tokens       ||
|| `[Alternative]` || sequence of alternatives ||

=Alternative=

|| *type*        || *description*                      ||
|| `[String]`    ||                                    ||
|| `[String]`    ||                                    ||

=!CncFun=

|| *type*        || *description*                                   ||
|| `String`      || the name of the corresponding abstract function ||
|| `[Int]`       || list of indices into the sequences array        ||

=Production=

There are two kinds of productions:
 * application of some concrete function to a list of arguments:
   {{{A -> f[B,C]}}}
   where `f` is the function, `B` and `C` are the arguments and A is 
   the result category.

 * coercion from one concrete category to another:
   {{{A -> _[B]}}}
   where `B` is the initial category and `A` is the final i.e. the
   result category.

|| *type*  || *description*                                  ||
|| `Int`   || the forest id of the result category           ||
|| `Int8`  || tag which says what kind of production this is ||

1. if tag=0 then the production is of application kind and there are two more fields:
|| *type*   || *description*  ||
|| `Int`    || the index of the function in the functions array ||
|| `[Int]`  || list of arguments. Each integer is a forest ids  ||

2. if tag=1 then the production is coercion and there is one more field:
|| *type*   || *description*                     ||
|| `Int`    || forest id of the initial category ||

=!CncCat=

|| *type*        || *description*                                   ||
|| `String`      || the name of the corresponding concrete category ||
|| `Int`         || the first corresponding forest id               ||
|| `Int`         || the last corresponding forest id                ||
|| `[String]`    || list of label names                             ||

=Literal=

|| *type* || *description* ||
|| `Int8` || literal type  ||

1. type=0 - string
|| *type*   || *description* ||
|| `String` || value         ||

2. type=1 - integer
|| *type* || *description* ||
|| `Int`  || value         ||

3. type=2 - float
|| *type*  || *description* ||
|| `Float` || value         ||